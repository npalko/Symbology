// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Symbology.proto

#ifndef PROTOBUF_Symbology_2eproto__INCLUDED
#define PROTOBUF_Symbology_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2003000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2003001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
#include "Revision.pb.h"
// @@protoc_insertion_point(includes)

namespace symbology {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_Symbology_2eproto();
void protobuf_AssignDesc_Symbology_2eproto();
void protobuf_ShutdownFile_Symbology_2eproto();

class Country;
class CountrySeries;
class Currency;
class CurrencySeries;
class Market;
class MarketSeries;
class Instrument;
class InstrumentSeries;
class CounterParty;
class CounterPartySeries;
class Company;
class CompanySeries;
class Security;
class SecuritySeries;
class Symbol;
class SymbolSeries;
class ExchangeRate;
class ExchangeRateSeries;
class Price;
class PriceSeries;
class Event;
class EventSeries;

enum CounterParty_type {
  CounterParty_type_ISO = 0,
  CounterParty_type_SYNTHETIC = 1,
  CounterParty_type_BROKER = 2
};
bool CounterParty_type_IsValid(int value);
const CounterParty_type CounterParty_type_type_MIN = CounterParty_type_ISO;
const CounterParty_type CounterParty_type_type_MAX = CounterParty_type_BROKER;
const int CounterParty_type_type_ARRAYSIZE = CounterParty_type_type_MAX + 1;

const ::google::protobuf::EnumDescriptor* CounterParty_type_descriptor();
inline const ::std::string& CounterParty_type_Name(CounterParty_type value) {
  return ::google::protobuf::internal::NameOfEnum(
    CounterParty_type_descriptor(), value);
}
inline bool CounterParty_type_Parse(
    const ::std::string& name, CounterParty_type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CounterParty_type>(
    CounterParty_type_descriptor(), name, value);
}
enum Symbol_type {
  Symbol_type_CUSIP = 0,
  Symbol_type_ISIN = 1,
  Symbol_type_SEDOL = 2,
  Symbol_type_VENDOR = 3
};
bool Symbol_type_IsValid(int value);
const Symbol_type Symbol_type_type_MIN = Symbol_type_CUSIP;
const Symbol_type Symbol_type_type_MAX = Symbol_type_VENDOR;
const int Symbol_type_type_ARRAYSIZE = Symbol_type_type_MAX + 1;

const ::google::protobuf::EnumDescriptor* Symbol_type_descriptor();
inline const ::std::string& Symbol_type_Name(Symbol_type value) {
  return ::google::protobuf::internal::NameOfEnum(
    Symbol_type_descriptor(), value);
}
inline bool Symbol_type_Parse(
    const ::std::string& name, Symbol_type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Symbol_type>(
    Symbol_type_descriptor(), name, value);
}
// ===================================================================

class Country : public ::google::protobuf::Message {
 public:
  Country();
  virtual ~Country();
  
  Country(const Country& from);
  
  inline Country& operator=(const Country& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Country& default_instance();
  
  void Swap(Country* other);
  
  // implements Message ----------------------------------------------
  
  Country* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Country& from);
  void MergeFrom(const Country& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);
  
  // optional .Revision revision = 2;
  inline bool has_revision() const;
  inline void clear_revision();
  static const int kRevisionFieldNumber = 2;
  inline const ::Revision& revision() const;
  inline ::Revision* mutable_revision();
  
  // optional string name = 3;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 3;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  
  // optional int32 isoNumber = 4;
  inline bool has_isonumber() const;
  inline void clear_isonumber();
  static const int kIsoNumberFieldNumber = 4;
  inline ::google::protobuf::int32 isonumber() const;
  inline void set_isonumber(::google::protobuf::int32 value);
  
  // optional string iso2Code = 5;
  inline bool has_iso2code() const;
  inline void clear_iso2code();
  static const int kIso2CodeFieldNumber = 5;
  inline const ::std::string& iso2code() const;
  inline void set_iso2code(const ::std::string& value);
  inline void set_iso2code(const char* value);
  inline void set_iso2code(const char* value, size_t size);
  inline ::std::string* mutable_iso2code();
  
  // optional string iso3Code = 6;
  inline bool has_iso3code() const;
  inline void clear_iso3code();
  static const int kIso3CodeFieldNumber = 6;
  inline const ::std::string& iso3code() const;
  inline void set_iso3code(const ::std::string& value);
  inline void set_iso3code(const char* value);
  inline void set_iso3code(const char* value, size_t size);
  inline ::std::string* mutable_iso3code();
  
  // @@protoc_insertion_point(class_scope:symbology.Country)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::int32 id_;
  ::Revision* revision_;
  ::std::string* name_;
  static const ::std::string _default_name_;
  ::google::protobuf::int32 isonumber_;
  ::std::string* iso2code_;
  static const ::std::string _default_iso2code_;
  ::std::string* iso3code_;
  static const ::std::string _default_iso3code_;
  friend void  protobuf_AddDesc_Symbology_2eproto();
  friend void protobuf_AssignDesc_Symbology_2eproto();
  friend void protobuf_ShutdownFile_Symbology_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static Country* default_instance_;
};
// -------------------------------------------------------------------

class CountrySeries : public ::google::protobuf::Message {
 public:
  CountrySeries();
  virtual ~CountrySeries();
  
  CountrySeries(const CountrySeries& from);
  
  inline CountrySeries& operator=(const CountrySeries& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const CountrySeries& default_instance();
  
  void Swap(CountrySeries* other);
  
  // implements Message ----------------------------------------------
  
  CountrySeries* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CountrySeries& from);
  void MergeFrom(const CountrySeries& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .symbology.Country country = 1;
  inline int country_size() const;
  inline void clear_country();
  static const int kCountryFieldNumber = 1;
  inline const ::symbology::Country& country(int index) const;
  inline ::symbology::Country* mutable_country(int index);
  inline ::symbology::Country* add_country();
  inline const ::google::protobuf::RepeatedPtrField< ::symbology::Country >&
      country() const;
  inline ::google::protobuf::RepeatedPtrField< ::symbology::Country >*
      mutable_country();
  
  // @@protoc_insertion_point(class_scope:symbology.CountrySeries)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::RepeatedPtrField< ::symbology::Country > country_;
  friend void  protobuf_AddDesc_Symbology_2eproto();
  friend void protobuf_AssignDesc_Symbology_2eproto();
  friend void protobuf_ShutdownFile_Symbology_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static CountrySeries* default_instance_;
};
// -------------------------------------------------------------------

class Currency : public ::google::protobuf::Message {
 public:
  Currency();
  virtual ~Currency();
  
  Currency(const Currency& from);
  
  inline Currency& operator=(const Currency& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Currency& default_instance();
  
  void Swap(Currency* other);
  
  // implements Message ----------------------------------------------
  
  Currency* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Currency& from);
  void MergeFrom(const Currency& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);
  
  // optional .Revision revision = 2;
  inline bool has_revision() const;
  inline void clear_revision();
  static const int kRevisionFieldNumber = 2;
  inline const ::Revision& revision() const;
  inline ::Revision* mutable_revision();
  
  // optional string name = 3;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 3;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  
  // optional int32 isoNumber = 4;
  inline bool has_isonumber() const;
  inline void clear_isonumber();
  static const int kIsoNumberFieldNumber = 4;
  inline ::google::protobuf::int32 isonumber() const;
  inline void set_isonumber(::google::protobuf::int32 value);
  
  // optional string isoCode = 5;
  inline bool has_isocode() const;
  inline void clear_isocode();
  static const int kIsoCodeFieldNumber = 5;
  inline const ::std::string& isocode() const;
  inline void set_isocode(const ::std::string& value);
  inline void set_isocode(const char* value);
  inline void set_isocode(const char* value, size_t size);
  inline ::std::string* mutable_isocode();
  
  // @@protoc_insertion_point(class_scope:symbology.Currency)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::int32 id_;
  ::Revision* revision_;
  ::std::string* name_;
  static const ::std::string _default_name_;
  ::google::protobuf::int32 isonumber_;
  ::std::string* isocode_;
  static const ::std::string _default_isocode_;
  friend void  protobuf_AddDesc_Symbology_2eproto();
  friend void protobuf_AssignDesc_Symbology_2eproto();
  friend void protobuf_ShutdownFile_Symbology_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static Currency* default_instance_;
};
// -------------------------------------------------------------------

class CurrencySeries : public ::google::protobuf::Message {
 public:
  CurrencySeries();
  virtual ~CurrencySeries();
  
  CurrencySeries(const CurrencySeries& from);
  
  inline CurrencySeries& operator=(const CurrencySeries& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const CurrencySeries& default_instance();
  
  void Swap(CurrencySeries* other);
  
  // implements Message ----------------------------------------------
  
  CurrencySeries* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CurrencySeries& from);
  void MergeFrom(const CurrencySeries& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .symbology.Currency currency = 1;
  inline int currency_size() const;
  inline void clear_currency();
  static const int kCurrencyFieldNumber = 1;
  inline const ::symbology::Currency& currency(int index) const;
  inline ::symbology::Currency* mutable_currency(int index);
  inline ::symbology::Currency* add_currency();
  inline const ::google::protobuf::RepeatedPtrField< ::symbology::Currency >&
      currency() const;
  inline ::google::protobuf::RepeatedPtrField< ::symbology::Currency >*
      mutable_currency();
  
  // @@protoc_insertion_point(class_scope:symbology.CurrencySeries)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::RepeatedPtrField< ::symbology::Currency > currency_;
  friend void  protobuf_AddDesc_Symbology_2eproto();
  friend void protobuf_AssignDesc_Symbology_2eproto();
  friend void protobuf_ShutdownFile_Symbology_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static CurrencySeries* default_instance_;
};
// -------------------------------------------------------------------

class Market : public ::google::protobuf::Message {
 public:
  Market();
  virtual ~Market();
  
  Market(const Market& from);
  
  inline Market& operator=(const Market& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Market& default_instance();
  
  void Swap(Market* other);
  
  // implements Message ----------------------------------------------
  
  Market* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Market& from);
  void MergeFrom(const Market& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);
  
  // optional .Revision revision = 2;
  inline bool has_revision() const;
  inline void clear_revision();
  static const int kRevisionFieldNumber = 2;
  inline const ::Revision& revision() const;
  inline ::Revision* mutable_revision();
  
  // optional string name = 3;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 3;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  
  // optional string isoCode = 4;
  inline bool has_isocode() const;
  inline void clear_isocode();
  static const int kIsoCodeFieldNumber = 4;
  inline const ::std::string& isocode() const;
  inline void set_isocode(const ::std::string& value);
  inline void set_isocode(const char* value);
  inline void set_isocode(const char* value, size_t size);
  inline ::std::string* mutable_isocode();
  
  // optional .symbology.Country country = 5;
  inline bool has_country() const;
  inline void clear_country();
  static const int kCountryFieldNumber = 5;
  inline const ::symbology::Country& country() const;
  inline ::symbology::Country* mutable_country();
  
  // optional string city = 6;
  inline bool has_city() const;
  inline void clear_city();
  static const int kCityFieldNumber = 6;
  inline const ::std::string& city() const;
  inline void set_city(const ::std::string& value);
  inline void set_city(const char* value);
  inline void set_city(const char* value, size_t size);
  inline ::std::string* mutable_city();
  
  // optional string website = 7;
  inline bool has_website() const;
  inline void clear_website();
  static const int kWebsiteFieldNumber = 7;
  inline const ::std::string& website() const;
  inline void set_website(const ::std::string& value);
  inline void set_website(const char* value);
  inline void set_website(const char* value, size_t size);
  inline ::std::string* mutable_website();
  
  // @@protoc_insertion_point(class_scope:symbology.Market)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::int32 id_;
  ::Revision* revision_;
  ::std::string* name_;
  static const ::std::string _default_name_;
  ::std::string* isocode_;
  static const ::std::string _default_isocode_;
  ::symbology::Country* country_;
  ::std::string* city_;
  static const ::std::string _default_city_;
  ::std::string* website_;
  static const ::std::string _default_website_;
  friend void  protobuf_AddDesc_Symbology_2eproto();
  friend void protobuf_AssignDesc_Symbology_2eproto();
  friend void protobuf_ShutdownFile_Symbology_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static Market* default_instance_;
};
// -------------------------------------------------------------------

class MarketSeries : public ::google::protobuf::Message {
 public:
  MarketSeries();
  virtual ~MarketSeries();
  
  MarketSeries(const MarketSeries& from);
  
  inline MarketSeries& operator=(const MarketSeries& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MarketSeries& default_instance();
  
  void Swap(MarketSeries* other);
  
  // implements Message ----------------------------------------------
  
  MarketSeries* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MarketSeries& from);
  void MergeFrom(const MarketSeries& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .symbology.Market market = 1;
  inline int market_size() const;
  inline void clear_market();
  static const int kMarketFieldNumber = 1;
  inline const ::symbology::Market& market(int index) const;
  inline ::symbology::Market* mutable_market(int index);
  inline ::symbology::Market* add_market();
  inline const ::google::protobuf::RepeatedPtrField< ::symbology::Market >&
      market() const;
  inline ::google::protobuf::RepeatedPtrField< ::symbology::Market >*
      mutable_market();
  
  // @@protoc_insertion_point(class_scope:symbology.MarketSeries)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::RepeatedPtrField< ::symbology::Market > market_;
  friend void  protobuf_AddDesc_Symbology_2eproto();
  friend void protobuf_AssignDesc_Symbology_2eproto();
  friend void protobuf_ShutdownFile_Symbology_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MarketSeries* default_instance_;
};
// -------------------------------------------------------------------

class Instrument : public ::google::protobuf::Message {
 public:
  Instrument();
  virtual ~Instrument();
  
  Instrument(const Instrument& from);
  
  inline Instrument& operator=(const Instrument& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Instrument& default_instance();
  
  void Swap(Instrument* other);
  
  // implements Message ----------------------------------------------
  
  Instrument* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Instrument& from);
  void MergeFrom(const Instrument& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);
  
  // optional .Revision revision = 2;
  inline bool has_revision() const;
  inline void clear_revision();
  static const int kRevisionFieldNumber = 2;
  inline const ::Revision& revision() const;
  inline ::Revision* mutable_revision();
  
  // optional int32 parentId = 3;
  inline bool has_parentid() const;
  inline void clear_parentid();
  static const int kParentIdFieldNumber = 3;
  inline ::google::protobuf::int32 parentid() const;
  inline void set_parentid(::google::protobuf::int32 value);
  
  // optional string name = 4;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 4;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  
  // @@protoc_insertion_point(class_scope:symbology.Instrument)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::int32 id_;
  ::Revision* revision_;
  ::google::protobuf::int32 parentid_;
  ::std::string* name_;
  static const ::std::string _default_name_;
  friend void  protobuf_AddDesc_Symbology_2eproto();
  friend void protobuf_AssignDesc_Symbology_2eproto();
  friend void protobuf_ShutdownFile_Symbology_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static Instrument* default_instance_;
};
// -------------------------------------------------------------------

class InstrumentSeries : public ::google::protobuf::Message {
 public:
  InstrumentSeries();
  virtual ~InstrumentSeries();
  
  InstrumentSeries(const InstrumentSeries& from);
  
  inline InstrumentSeries& operator=(const InstrumentSeries& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const InstrumentSeries& default_instance();
  
  void Swap(InstrumentSeries* other);
  
  // implements Message ----------------------------------------------
  
  InstrumentSeries* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InstrumentSeries& from);
  void MergeFrom(const InstrumentSeries& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .symbology.Instrument instrument = 1;
  inline int instrument_size() const;
  inline void clear_instrument();
  static const int kInstrumentFieldNumber = 1;
  inline const ::symbology::Instrument& instrument(int index) const;
  inline ::symbology::Instrument* mutable_instrument(int index);
  inline ::symbology::Instrument* add_instrument();
  inline const ::google::protobuf::RepeatedPtrField< ::symbology::Instrument >&
      instrument() const;
  inline ::google::protobuf::RepeatedPtrField< ::symbology::Instrument >*
      mutable_instrument();
  
  // @@protoc_insertion_point(class_scope:symbology.InstrumentSeries)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::RepeatedPtrField< ::symbology::Instrument > instrument_;
  friend void  protobuf_AddDesc_Symbology_2eproto();
  friend void protobuf_AssignDesc_Symbology_2eproto();
  friend void protobuf_ShutdownFile_Symbology_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static InstrumentSeries* default_instance_;
};
// -------------------------------------------------------------------

class CounterParty : public ::google::protobuf::Message {
 public:
  CounterParty();
  virtual ~CounterParty();
  
  CounterParty(const CounterParty& from);
  
  inline CounterParty& operator=(const CounterParty& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const CounterParty& default_instance();
  
  void Swap(CounterParty* other);
  
  // implements Message ----------------------------------------------
  
  CounterParty* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CounterParty& from);
  void MergeFrom(const CounterParty& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef CounterParty_type type;
  static const type ISO = CounterParty_type_ISO;
  static const type SYNTHETIC = CounterParty_type_SYNTHETIC;
  static const type BROKER = CounterParty_type_BROKER;
  static inline bool type_IsValid(int value) {
    return CounterParty_type_IsValid(value);
  }
  static const type type_MIN =
    CounterParty_type_type_MIN;
  static const type type_MAX =
    CounterParty_type_type_MAX;
  static const int type_ARRAYSIZE =
    CounterParty_type_type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  type_descriptor() {
    return CounterParty_type_descriptor();
  }
  static inline const ::std::string& type_Name(type value) {
    return CounterParty_type_Name(value);
  }
  static inline bool type_Parse(const ::std::string& name,
      type* value) {
    return CounterParty_type_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // optional int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);
  
  // optional .Revision revision = 2;
  inline bool has_revision() const;
  inline void clear_revision();
  static const int kRevisionFieldNumber = 2;
  inline const ::Revision& revision() const;
  inline ::Revision* mutable_revision();
  
  // optional string name = 3;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 3;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  
  // optional string isoCode = 4;
  inline bool has_isocode() const;
  inline void clear_isocode();
  static const int kIsoCodeFieldNumber = 4;
  inline const ::std::string& isocode() const;
  inline void set_isocode(const ::std::string& value);
  inline void set_isocode(const char* value);
  inline void set_isocode(const char* value, size_t size);
  inline ::std::string* mutable_isocode();
  
  // optional string website = 5;
  inline bool has_website() const;
  inline void clear_website();
  static const int kWebsiteFieldNumber = 5;
  inline const ::std::string& website() const;
  inline void set_website(const ::std::string& value);
  inline void set_website(const char* value);
  inline void set_website(const char* value, size_t size);
  inline ::std::string* mutable_website();
  
  // @@protoc_insertion_point(class_scope:symbology.CounterParty)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::int32 id_;
  ::Revision* revision_;
  ::std::string* name_;
  static const ::std::string _default_name_;
  ::std::string* isocode_;
  static const ::std::string _default_isocode_;
  ::std::string* website_;
  static const ::std::string _default_website_;
  friend void  protobuf_AddDesc_Symbology_2eproto();
  friend void protobuf_AssignDesc_Symbology_2eproto();
  friend void protobuf_ShutdownFile_Symbology_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static CounterParty* default_instance_;
};
// -------------------------------------------------------------------

class CounterPartySeries : public ::google::protobuf::Message {
 public:
  CounterPartySeries();
  virtual ~CounterPartySeries();
  
  CounterPartySeries(const CounterPartySeries& from);
  
  inline CounterPartySeries& operator=(const CounterPartySeries& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const CounterPartySeries& default_instance();
  
  void Swap(CounterPartySeries* other);
  
  // implements Message ----------------------------------------------
  
  CounterPartySeries* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CounterPartySeries& from);
  void MergeFrom(const CounterPartySeries& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .symbology.CounterParty counterParty = 1;
  inline int counterparty_size() const;
  inline void clear_counterparty();
  static const int kCounterPartyFieldNumber = 1;
  inline const ::symbology::CounterParty& counterparty(int index) const;
  inline ::symbology::CounterParty* mutable_counterparty(int index);
  inline ::symbology::CounterParty* add_counterparty();
  inline const ::google::protobuf::RepeatedPtrField< ::symbology::CounterParty >&
      counterparty() const;
  inline ::google::protobuf::RepeatedPtrField< ::symbology::CounterParty >*
      mutable_counterparty();
  
  // @@protoc_insertion_point(class_scope:symbology.CounterPartySeries)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::RepeatedPtrField< ::symbology::CounterParty > counterparty_;
  friend void  protobuf_AddDesc_Symbology_2eproto();
  friend void protobuf_AssignDesc_Symbology_2eproto();
  friend void protobuf_ShutdownFile_Symbology_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static CounterPartySeries* default_instance_;
};
// -------------------------------------------------------------------

class Company : public ::google::protobuf::Message {
 public:
  Company();
  virtual ~Company();
  
  Company(const Company& from);
  
  inline Company& operator=(const Company& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Company& default_instance();
  
  void Swap(Company* other);
  
  // implements Message ----------------------------------------------
  
  Company* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Company& from);
  void MergeFrom(const Company& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);
  
  // optional .Revision revision = 2;
  inline bool has_revision() const;
  inline void clear_revision();
  static const int kRevisionFieldNumber = 2;
  inline const ::Revision& revision() const;
  inline ::Revision* mutable_revision();
  
  // optional string name = 3;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 3;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  
  // @@protoc_insertion_point(class_scope:symbology.Company)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::int32 id_;
  ::Revision* revision_;
  ::std::string* name_;
  static const ::std::string _default_name_;
  friend void  protobuf_AddDesc_Symbology_2eproto();
  friend void protobuf_AssignDesc_Symbology_2eproto();
  friend void protobuf_ShutdownFile_Symbology_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static Company* default_instance_;
};
// -------------------------------------------------------------------

class CompanySeries : public ::google::protobuf::Message {
 public:
  CompanySeries();
  virtual ~CompanySeries();
  
  CompanySeries(const CompanySeries& from);
  
  inline CompanySeries& operator=(const CompanySeries& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const CompanySeries& default_instance();
  
  void Swap(CompanySeries* other);
  
  // implements Message ----------------------------------------------
  
  CompanySeries* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CompanySeries& from);
  void MergeFrom(const CompanySeries& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .symbology.Company company = 1;
  inline int company_size() const;
  inline void clear_company();
  static const int kCompanyFieldNumber = 1;
  inline const ::symbology::Company& company(int index) const;
  inline ::symbology::Company* mutable_company(int index);
  inline ::symbology::Company* add_company();
  inline const ::google::protobuf::RepeatedPtrField< ::symbology::Company >&
      company() const;
  inline ::google::protobuf::RepeatedPtrField< ::symbology::Company >*
      mutable_company();
  
  // @@protoc_insertion_point(class_scope:symbology.CompanySeries)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::RepeatedPtrField< ::symbology::Company > company_;
  friend void  protobuf_AddDesc_Symbology_2eproto();
  friend void protobuf_AssignDesc_Symbology_2eproto();
  friend void protobuf_ShutdownFile_Symbology_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static CompanySeries* default_instance_;
};
// -------------------------------------------------------------------

class Security : public ::google::protobuf::Message {
 public:
  Security();
  virtual ~Security();
  
  Security(const Security& from);
  
  inline Security& operator=(const Security& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Security& default_instance();
  
  void Swap(Security* other);
  
  // implements Message ----------------------------------------------
  
  Security* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Security& from);
  void MergeFrom(const Security& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);
  
  // optional .Revision revision = 2;
  inline bool has_revision() const;
  inline void clear_revision();
  static const int kRevisionFieldNumber = 2;
  inline const ::Revision& revision() const;
  inline ::Revision* mutable_revision();
  
  // optional string name = 3;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 3;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  
  // optional .symbology.Instrument instrument = 4;
  inline bool has_instrument() const;
  inline void clear_instrument();
  static const int kInstrumentFieldNumber = 4;
  inline const ::symbology::Instrument& instrument() const;
  inline ::symbology::Instrument* mutable_instrument();
  
  // optional .symbology.Company company = 5;
  inline bool has_company() const;
  inline void clear_company();
  static const int kCompanyFieldNumber = 5;
  inline const ::symbology::Company& company() const;
  inline ::symbology::Company* mutable_company();
  
  // optional .symbology.Currency currency = 6;
  inline bool has_currency() const;
  inline void clear_currency();
  static const int kCurrencyFieldNumber = 6;
  inline const ::symbology::Currency& currency() const;
  inline ::symbology::Currency* mutable_currency();
  
  // optional int32 strike = 7;
  inline bool has_strike() const;
  inline void clear_strike();
  static const int kStrikeFieldNumber = 7;
  inline ::google::protobuf::int32 strike() const;
  inline void set_strike(::google::protobuf::int32 value);
  
  // optional int32 expirationDate = 8;
  inline bool has_expirationdate() const;
  inline void clear_expirationdate();
  static const int kExpirationDateFieldNumber = 8;
  inline ::google::protobuf::int32 expirationdate() const;
  inline void set_expirationdate(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:symbology.Security)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::int32 id_;
  ::Revision* revision_;
  ::std::string* name_;
  static const ::std::string _default_name_;
  ::symbology::Instrument* instrument_;
  ::symbology::Company* company_;
  ::symbology::Currency* currency_;
  ::google::protobuf::int32 strike_;
  ::google::protobuf::int32 expirationdate_;
  friend void  protobuf_AddDesc_Symbology_2eproto();
  friend void protobuf_AssignDesc_Symbology_2eproto();
  friend void protobuf_ShutdownFile_Symbology_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static Security* default_instance_;
};
// -------------------------------------------------------------------

class SecuritySeries : public ::google::protobuf::Message {
 public:
  SecuritySeries();
  virtual ~SecuritySeries();
  
  SecuritySeries(const SecuritySeries& from);
  
  inline SecuritySeries& operator=(const SecuritySeries& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const SecuritySeries& default_instance();
  
  void Swap(SecuritySeries* other);
  
  // implements Message ----------------------------------------------
  
  SecuritySeries* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SecuritySeries& from);
  void MergeFrom(const SecuritySeries& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .symbology.Security security = 1;
  inline int security_size() const;
  inline void clear_security();
  static const int kSecurityFieldNumber = 1;
  inline const ::symbology::Security& security(int index) const;
  inline ::symbology::Security* mutable_security(int index);
  inline ::symbology::Security* add_security();
  inline const ::google::protobuf::RepeatedPtrField< ::symbology::Security >&
      security() const;
  inline ::google::protobuf::RepeatedPtrField< ::symbology::Security >*
      mutable_security();
  
  // @@protoc_insertion_point(class_scope:symbology.SecuritySeries)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::RepeatedPtrField< ::symbology::Security > security_;
  friend void  protobuf_AddDesc_Symbology_2eproto();
  friend void protobuf_AssignDesc_Symbology_2eproto();
  friend void protobuf_ShutdownFile_Symbology_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static SecuritySeries* default_instance_;
};
// -------------------------------------------------------------------

class Symbol : public ::google::protobuf::Message {
 public:
  Symbol();
  virtual ~Symbol();
  
  Symbol(const Symbol& from);
  
  inline Symbol& operator=(const Symbol& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Symbol& default_instance();
  
  void Swap(Symbol* other);
  
  // implements Message ----------------------------------------------
  
  Symbol* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Symbol& from);
  void MergeFrom(const Symbol& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef Symbol_type type;
  static const type CUSIP = Symbol_type_CUSIP;
  static const type ISIN = Symbol_type_ISIN;
  static const type SEDOL = Symbol_type_SEDOL;
  static const type VENDOR = Symbol_type_VENDOR;
  static inline bool type_IsValid(int value) {
    return Symbol_type_IsValid(value);
  }
  static const type type_MIN =
    Symbol_type_type_MIN;
  static const type type_MAX =
    Symbol_type_type_MAX;
  static const int type_ARRAYSIZE =
    Symbol_type_type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  type_descriptor() {
    return Symbol_type_descriptor();
  }
  static inline const ::std::string& type_Name(type value) {
    return Symbol_type_Name(value);
  }
  static inline bool type_Parse(const ::std::string& name,
      type* value) {
    return Symbol_type_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // optional int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);
  
  // optional .Revision revision = 2;
  inline bool has_revision() const;
  inline void clear_revision();
  static const int kRevisionFieldNumber = 2;
  inline const ::Revision& revision() const;
  inline ::Revision* mutable_revision();
  
  // optional .symbology.Currency currency = 3;
  inline bool has_currency() const;
  inline void clear_currency();
  static const int kCurrencyFieldNumber = 3;
  inline const ::symbology::Currency& currency() const;
  inline ::symbology::Currency* mutable_currency();
  
  // optional .symbology.Security security = 4;
  inline bool has_security() const;
  inline void clear_security();
  static const int kSecurityFieldNumber = 4;
  inline const ::symbology::Security& security() const;
  inline ::symbology::Security* mutable_security();
  
  // optional .symbology.CounterParty counterParty = 5;
  inline bool has_counterparty() const;
  inline void clear_counterparty();
  static const int kCounterPartyFieldNumber = 5;
  inline const ::symbology::CounterParty& counterparty() const;
  inline ::symbology::CounterParty* mutable_counterparty();
  
  // optional string name = 6;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 6;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  
  // @@protoc_insertion_point(class_scope:symbology.Symbol)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::int32 id_;
  ::Revision* revision_;
  ::symbology::Currency* currency_;
  ::symbology::Security* security_;
  ::symbology::CounterParty* counterparty_;
  ::std::string* name_;
  static const ::std::string _default_name_;
  friend void  protobuf_AddDesc_Symbology_2eproto();
  friend void protobuf_AssignDesc_Symbology_2eproto();
  friend void protobuf_ShutdownFile_Symbology_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static Symbol* default_instance_;
};
// -------------------------------------------------------------------

class SymbolSeries : public ::google::protobuf::Message {
 public:
  SymbolSeries();
  virtual ~SymbolSeries();
  
  SymbolSeries(const SymbolSeries& from);
  
  inline SymbolSeries& operator=(const SymbolSeries& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const SymbolSeries& default_instance();
  
  void Swap(SymbolSeries* other);
  
  // implements Message ----------------------------------------------
  
  SymbolSeries* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SymbolSeries& from);
  void MergeFrom(const SymbolSeries& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .symbology.Symbol symbol = 1;
  inline int symbol_size() const;
  inline void clear_symbol();
  static const int kSymbolFieldNumber = 1;
  inline const ::symbology::Symbol& symbol(int index) const;
  inline ::symbology::Symbol* mutable_symbol(int index);
  inline ::symbology::Symbol* add_symbol();
  inline const ::google::protobuf::RepeatedPtrField< ::symbology::Symbol >&
      symbol() const;
  inline ::google::protobuf::RepeatedPtrField< ::symbology::Symbol >*
      mutable_symbol();
  
  // @@protoc_insertion_point(class_scope:symbology.SymbolSeries)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::RepeatedPtrField< ::symbology::Symbol > symbol_;
  friend void  protobuf_AddDesc_Symbology_2eproto();
  friend void protobuf_AssignDesc_Symbology_2eproto();
  friend void protobuf_ShutdownFile_Symbology_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static SymbolSeries* default_instance_;
};
// -------------------------------------------------------------------

class ExchangeRate : public ::google::protobuf::Message {
 public:
  ExchangeRate();
  virtual ~ExchangeRate();
  
  ExchangeRate(const ExchangeRate& from);
  
  inline ExchangeRate& operator=(const ExchangeRate& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ExchangeRate& default_instance();
  
  void Swap(ExchangeRate* other);
  
  // implements Message ----------------------------------------------
  
  ExchangeRate* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ExchangeRate& from);
  void MergeFrom(const ExchangeRate& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);
  
  // optional .Revision revision = 2;
  inline bool has_revision() const;
  inline void clear_revision();
  static const int kRevisionFieldNumber = 2;
  inline const ::Revision& revision() const;
  inline ::Revision* mutable_revision();
  
  // optional .symbology.Currency toCurrency = 3;
  inline bool has_tocurrency() const;
  inline void clear_tocurrency();
  static const int kToCurrencyFieldNumber = 3;
  inline const ::symbology::Currency& tocurrency() const;
  inline ::symbology::Currency* mutable_tocurrency();
  
  // optional .symbology.Currency fromCurrency = 4;
  inline bool has_fromcurrency() const;
  inline void clear_fromcurrency();
  static const int kFromCurrencyFieldNumber = 4;
  inline const ::symbology::Currency& fromcurrency() const;
  inline ::symbology::Currency* mutable_fromcurrency();
  
  // optional .symbology.CounterParty counterParty = 5;
  inline bool has_counterparty() const;
  inline void clear_counterparty();
  static const int kCounterPartyFieldNumber = 5;
  inline const ::symbology::CounterParty& counterparty() const;
  inline ::symbology::CounterParty* mutable_counterparty();
  
  // optional int64 time = 6;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 6;
  inline ::google::protobuf::int64 time() const;
  inline void set_time(::google::protobuf::int64 value);
  
  // optional int32 rate = 7;
  inline bool has_rate() const;
  inline void clear_rate();
  static const int kRateFieldNumber = 7;
  inline ::google::protobuf::int32 rate() const;
  inline void set_rate(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:symbology.ExchangeRate)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::int32 id_;
  ::Revision* revision_;
  ::symbology::Currency* tocurrency_;
  ::symbology::Currency* fromcurrency_;
  ::symbology::CounterParty* counterparty_;
  ::google::protobuf::int64 time_;
  ::google::protobuf::int32 rate_;
  friend void  protobuf_AddDesc_Symbology_2eproto();
  friend void protobuf_AssignDesc_Symbology_2eproto();
  friend void protobuf_ShutdownFile_Symbology_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static ExchangeRate* default_instance_;
};
// -------------------------------------------------------------------

class ExchangeRateSeries : public ::google::protobuf::Message {
 public:
  ExchangeRateSeries();
  virtual ~ExchangeRateSeries();
  
  ExchangeRateSeries(const ExchangeRateSeries& from);
  
  inline ExchangeRateSeries& operator=(const ExchangeRateSeries& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ExchangeRateSeries& default_instance();
  
  void Swap(ExchangeRateSeries* other);
  
  // implements Message ----------------------------------------------
  
  ExchangeRateSeries* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ExchangeRateSeries& from);
  void MergeFrom(const ExchangeRateSeries& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .symbology.ExchangeRate exchangeRate = 1;
  inline int exchangerate_size() const;
  inline void clear_exchangerate();
  static const int kExchangeRateFieldNumber = 1;
  inline const ::symbology::ExchangeRate& exchangerate(int index) const;
  inline ::symbology::ExchangeRate* mutable_exchangerate(int index);
  inline ::symbology::ExchangeRate* add_exchangerate();
  inline const ::google::protobuf::RepeatedPtrField< ::symbology::ExchangeRate >&
      exchangerate() const;
  inline ::google::protobuf::RepeatedPtrField< ::symbology::ExchangeRate >*
      mutable_exchangerate();
  
  // @@protoc_insertion_point(class_scope:symbology.ExchangeRateSeries)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::RepeatedPtrField< ::symbology::ExchangeRate > exchangerate_;
  friend void  protobuf_AddDesc_Symbology_2eproto();
  friend void protobuf_AssignDesc_Symbology_2eproto();
  friend void protobuf_ShutdownFile_Symbology_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static ExchangeRateSeries* default_instance_;
};
// -------------------------------------------------------------------

class Price : public ::google::protobuf::Message {
 public:
  Price();
  virtual ~Price();
  
  Price(const Price& from);
  
  inline Price& operator=(const Price& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Price& default_instance();
  
  void Swap(Price* other);
  
  // implements Message ----------------------------------------------
  
  Price* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Price& from);
  void MergeFrom(const Price& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);
  
  // optional .Revision revision = 2;
  inline bool has_revision() const;
  inline void clear_revision();
  static const int kRevisionFieldNumber = 2;
  inline const ::Revision& revision() const;
  inline ::Revision* mutable_revision();
  
  // optional .symbology.Security security = 3;
  inline bool has_security() const;
  inline void clear_security();
  static const int kSecurityFieldNumber = 3;
  inline const ::symbology::Security& security() const;
  inline ::symbology::Security* mutable_security();
  
  // optional .symbology.CounterParty counterParty = 4;
  inline bool has_counterparty() const;
  inline void clear_counterparty();
  static const int kCounterPartyFieldNumber = 4;
  inline const ::symbology::CounterParty& counterparty() const;
  inline ::symbology::CounterParty* mutable_counterparty();
  
  // optional .symbology.Currency currency = 5;
  inline bool has_currency() const;
  inline void clear_currency();
  static const int kCurrencyFieldNumber = 5;
  inline const ::symbology::Currency& currency() const;
  inline ::symbology::Currency* mutable_currency();
  
  // optional int32 date = 6;
  inline bool has_date() const;
  inline void clear_date();
  static const int kDateFieldNumber = 6;
  inline ::google::protobuf::int32 date() const;
  inline void set_date(::google::protobuf::int32 value);
  
  // optional int32 bid = 7;
  inline bool has_bid() const;
  inline void clear_bid();
  static const int kBidFieldNumber = 7;
  inline ::google::protobuf::int32 bid() const;
  inline void set_bid(::google::protobuf::int32 value);
  
  // optional int32 ask = 8;
  inline bool has_ask() const;
  inline void clear_ask();
  static const int kAskFieldNumber = 8;
  inline ::google::protobuf::int32 ask() const;
  inline void set_ask(::google::protobuf::int32 value);
  
  // optional int32 open = 9;
  inline bool has_open() const;
  inline void clear_open();
  static const int kOpenFieldNumber = 9;
  inline ::google::protobuf::int32 open() const;
  inline void set_open(::google::protobuf::int32 value);
  
  // optional int32 close = 10;
  inline bool has_close() const;
  inline void clear_close();
  static const int kCloseFieldNumber = 10;
  inline ::google::protobuf::int32 close() const;
  inline void set_close(::google::protobuf::int32 value);
  
  // optional int32 high = 11;
  inline bool has_high() const;
  inline void clear_high();
  static const int kHighFieldNumber = 11;
  inline ::google::protobuf::int32 high() const;
  inline void set_high(::google::protobuf::int32 value);
  
  // optional int32 low = 12;
  inline bool has_low() const;
  inline void clear_low();
  static const int kLowFieldNumber = 12;
  inline ::google::protobuf::int32 low() const;
  inline void set_low(::google::protobuf::int32 value);
  
  // optional int32 volume = 13;
  inline bool has_volume() const;
  inline void clear_volume();
  static const int kVolumeFieldNumber = 13;
  inline ::google::protobuf::int32 volume() const;
  inline void set_volume(::google::protobuf::int32 value);
  
  // optional int32 return = 14;
  inline bool has_return_() const;
  inline void clear_return_();
  static const int kReturnFieldNumber = 14;
  inline ::google::protobuf::int32 return_() const;
  inline void set_return_(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:symbology.Price)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::int32 id_;
  ::Revision* revision_;
  ::symbology::Security* security_;
  ::symbology::CounterParty* counterparty_;
  ::symbology::Currency* currency_;
  ::google::protobuf::int32 date_;
  ::google::protobuf::int32 bid_;
  ::google::protobuf::int32 ask_;
  ::google::protobuf::int32 open_;
  ::google::protobuf::int32 close_;
  ::google::protobuf::int32 high_;
  ::google::protobuf::int32 low_;
  ::google::protobuf::int32 volume_;
  ::google::protobuf::int32 return__;
  friend void  protobuf_AddDesc_Symbology_2eproto();
  friend void protobuf_AssignDesc_Symbology_2eproto();
  friend void protobuf_ShutdownFile_Symbology_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(14 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static Price* default_instance_;
};
// -------------------------------------------------------------------

class PriceSeries : public ::google::protobuf::Message {
 public:
  PriceSeries();
  virtual ~PriceSeries();
  
  PriceSeries(const PriceSeries& from);
  
  inline PriceSeries& operator=(const PriceSeries& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const PriceSeries& default_instance();
  
  void Swap(PriceSeries* other);
  
  // implements Message ----------------------------------------------
  
  PriceSeries* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PriceSeries& from);
  void MergeFrom(const PriceSeries& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .symbology.Price price = 1;
  inline int price_size() const;
  inline void clear_price();
  static const int kPriceFieldNumber = 1;
  inline const ::symbology::Price& price(int index) const;
  inline ::symbology::Price* mutable_price(int index);
  inline ::symbology::Price* add_price();
  inline const ::google::protobuf::RepeatedPtrField< ::symbology::Price >&
      price() const;
  inline ::google::protobuf::RepeatedPtrField< ::symbology::Price >*
      mutable_price();
  
  // @@protoc_insertion_point(class_scope:symbology.PriceSeries)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::RepeatedPtrField< ::symbology::Price > price_;
  friend void  protobuf_AddDesc_Symbology_2eproto();
  friend void protobuf_AssignDesc_Symbology_2eproto();
  friend void protobuf_ShutdownFile_Symbology_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static PriceSeries* default_instance_;
};
// -------------------------------------------------------------------

class Event : public ::google::protobuf::Message {
 public:
  Event();
  virtual ~Event();
  
  Event(const Event& from);
  
  inline Event& operator=(const Event& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Event& default_instance();
  
  void Swap(Event* other);
  
  // implements Message ----------------------------------------------
  
  Event* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Event& from);
  void MergeFrom(const Event& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);
  
  // optional .Revision revision = 2;
  inline bool has_revision() const;
  inline void clear_revision();
  static const int kRevisionFieldNumber = 2;
  inline const ::Revision& revision() const;
  inline ::Revision* mutable_revision();
  
  // @@protoc_insertion_point(class_scope:symbology.Event)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::int32 id_;
  ::Revision* revision_;
  friend void  protobuf_AddDesc_Symbology_2eproto();
  friend void protobuf_AssignDesc_Symbology_2eproto();
  friend void protobuf_ShutdownFile_Symbology_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static Event* default_instance_;
};
// -------------------------------------------------------------------

class EventSeries : public ::google::protobuf::Message {
 public:
  EventSeries();
  virtual ~EventSeries();
  
  EventSeries(const EventSeries& from);
  
  inline EventSeries& operator=(const EventSeries& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const EventSeries& default_instance();
  
  void Swap(EventSeries* other);
  
  // implements Message ----------------------------------------------
  
  EventSeries* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EventSeries& from);
  void MergeFrom(const EventSeries& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .symbology.Event event = 1;
  inline int event_size() const;
  inline void clear_event();
  static const int kEventFieldNumber = 1;
  inline const ::symbology::Event& event(int index) const;
  inline ::symbology::Event* mutable_event(int index);
  inline ::symbology::Event* add_event();
  inline const ::google::protobuf::RepeatedPtrField< ::symbology::Event >&
      event() const;
  inline ::google::protobuf::RepeatedPtrField< ::symbology::Event >*
      mutable_event();
  
  // @@protoc_insertion_point(class_scope:symbology.EventSeries)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::RepeatedPtrField< ::symbology::Event > event_;
  friend void  protobuf_AddDesc_Symbology_2eproto();
  friend void protobuf_AssignDesc_Symbology_2eproto();
  friend void protobuf_ShutdownFile_Symbology_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static EventSeries* default_instance_;
};
// ===================================================================


// ===================================================================

// Country

// optional int32 id = 1;
inline bool Country::has_id() const {
  return _has_bit(0);
}
inline void Country::clear_id() {
  id_ = 0;
  _clear_bit(0);
}
inline ::google::protobuf::int32 Country::id() const {
  return id_;
}
inline void Country::set_id(::google::protobuf::int32 value) {
  _set_bit(0);
  id_ = value;
}

// optional .Revision revision = 2;
inline bool Country::has_revision() const {
  return _has_bit(1);
}
inline void Country::clear_revision() {
  if (revision_ != NULL) revision_->::Revision::Clear();
  _clear_bit(1);
}
inline const ::Revision& Country::revision() const {
  return revision_ != NULL ? *revision_ : *default_instance_->revision_;
}
inline ::Revision* Country::mutable_revision() {
  _set_bit(1);
  if (revision_ == NULL) revision_ = new ::Revision;
  return revision_;
}

// optional string name = 3;
inline bool Country::has_name() const {
  return _has_bit(2);
}
inline void Country::clear_name() {
  if (name_ != &_default_name_) {
    name_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& Country::name() const {
  return *name_;
}
inline void Country::set_name(const ::std::string& value) {
  _set_bit(2);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Country::set_name(const char* value) {
  _set_bit(2);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Country::set_name(const char* value, size_t size) {
  _set_bit(2);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Country::mutable_name() {
  _set_bit(2);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  return name_;
}

// optional int32 isoNumber = 4;
inline bool Country::has_isonumber() const {
  return _has_bit(3);
}
inline void Country::clear_isonumber() {
  isonumber_ = 0;
  _clear_bit(3);
}
inline ::google::protobuf::int32 Country::isonumber() const {
  return isonumber_;
}
inline void Country::set_isonumber(::google::protobuf::int32 value) {
  _set_bit(3);
  isonumber_ = value;
}

// optional string iso2Code = 5;
inline bool Country::has_iso2code() const {
  return _has_bit(4);
}
inline void Country::clear_iso2code() {
  if (iso2code_ != &_default_iso2code_) {
    iso2code_->clear();
  }
  _clear_bit(4);
}
inline const ::std::string& Country::iso2code() const {
  return *iso2code_;
}
inline void Country::set_iso2code(const ::std::string& value) {
  _set_bit(4);
  if (iso2code_ == &_default_iso2code_) {
    iso2code_ = new ::std::string;
  }
  iso2code_->assign(value);
}
inline void Country::set_iso2code(const char* value) {
  _set_bit(4);
  if (iso2code_ == &_default_iso2code_) {
    iso2code_ = new ::std::string;
  }
  iso2code_->assign(value);
}
inline void Country::set_iso2code(const char* value, size_t size) {
  _set_bit(4);
  if (iso2code_ == &_default_iso2code_) {
    iso2code_ = new ::std::string;
  }
  iso2code_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Country::mutable_iso2code() {
  _set_bit(4);
  if (iso2code_ == &_default_iso2code_) {
    iso2code_ = new ::std::string;
  }
  return iso2code_;
}

// optional string iso3Code = 6;
inline bool Country::has_iso3code() const {
  return _has_bit(5);
}
inline void Country::clear_iso3code() {
  if (iso3code_ != &_default_iso3code_) {
    iso3code_->clear();
  }
  _clear_bit(5);
}
inline const ::std::string& Country::iso3code() const {
  return *iso3code_;
}
inline void Country::set_iso3code(const ::std::string& value) {
  _set_bit(5);
  if (iso3code_ == &_default_iso3code_) {
    iso3code_ = new ::std::string;
  }
  iso3code_->assign(value);
}
inline void Country::set_iso3code(const char* value) {
  _set_bit(5);
  if (iso3code_ == &_default_iso3code_) {
    iso3code_ = new ::std::string;
  }
  iso3code_->assign(value);
}
inline void Country::set_iso3code(const char* value, size_t size) {
  _set_bit(5);
  if (iso3code_ == &_default_iso3code_) {
    iso3code_ = new ::std::string;
  }
  iso3code_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Country::mutable_iso3code() {
  _set_bit(5);
  if (iso3code_ == &_default_iso3code_) {
    iso3code_ = new ::std::string;
  }
  return iso3code_;
}

// -------------------------------------------------------------------

// CountrySeries

// repeated .symbology.Country country = 1;
inline int CountrySeries::country_size() const {
  return country_.size();
}
inline void CountrySeries::clear_country() {
  country_.Clear();
}
inline const ::symbology::Country& CountrySeries::country(int index) const {
  return country_.Get(index);
}
inline ::symbology::Country* CountrySeries::mutable_country(int index) {
  return country_.Mutable(index);
}
inline ::symbology::Country* CountrySeries::add_country() {
  return country_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::symbology::Country >&
CountrySeries::country() const {
  return country_;
}
inline ::google::protobuf::RepeatedPtrField< ::symbology::Country >*
CountrySeries::mutable_country() {
  return &country_;
}

// -------------------------------------------------------------------

// Currency

// optional int32 id = 1;
inline bool Currency::has_id() const {
  return _has_bit(0);
}
inline void Currency::clear_id() {
  id_ = 0;
  _clear_bit(0);
}
inline ::google::protobuf::int32 Currency::id() const {
  return id_;
}
inline void Currency::set_id(::google::protobuf::int32 value) {
  _set_bit(0);
  id_ = value;
}

// optional .Revision revision = 2;
inline bool Currency::has_revision() const {
  return _has_bit(1);
}
inline void Currency::clear_revision() {
  if (revision_ != NULL) revision_->::Revision::Clear();
  _clear_bit(1);
}
inline const ::Revision& Currency::revision() const {
  return revision_ != NULL ? *revision_ : *default_instance_->revision_;
}
inline ::Revision* Currency::mutable_revision() {
  _set_bit(1);
  if (revision_ == NULL) revision_ = new ::Revision;
  return revision_;
}

// optional string name = 3;
inline bool Currency::has_name() const {
  return _has_bit(2);
}
inline void Currency::clear_name() {
  if (name_ != &_default_name_) {
    name_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& Currency::name() const {
  return *name_;
}
inline void Currency::set_name(const ::std::string& value) {
  _set_bit(2);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Currency::set_name(const char* value) {
  _set_bit(2);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Currency::set_name(const char* value, size_t size) {
  _set_bit(2);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Currency::mutable_name() {
  _set_bit(2);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  return name_;
}

// optional int32 isoNumber = 4;
inline bool Currency::has_isonumber() const {
  return _has_bit(3);
}
inline void Currency::clear_isonumber() {
  isonumber_ = 0;
  _clear_bit(3);
}
inline ::google::protobuf::int32 Currency::isonumber() const {
  return isonumber_;
}
inline void Currency::set_isonumber(::google::protobuf::int32 value) {
  _set_bit(3);
  isonumber_ = value;
}

// optional string isoCode = 5;
inline bool Currency::has_isocode() const {
  return _has_bit(4);
}
inline void Currency::clear_isocode() {
  if (isocode_ != &_default_isocode_) {
    isocode_->clear();
  }
  _clear_bit(4);
}
inline const ::std::string& Currency::isocode() const {
  return *isocode_;
}
inline void Currency::set_isocode(const ::std::string& value) {
  _set_bit(4);
  if (isocode_ == &_default_isocode_) {
    isocode_ = new ::std::string;
  }
  isocode_->assign(value);
}
inline void Currency::set_isocode(const char* value) {
  _set_bit(4);
  if (isocode_ == &_default_isocode_) {
    isocode_ = new ::std::string;
  }
  isocode_->assign(value);
}
inline void Currency::set_isocode(const char* value, size_t size) {
  _set_bit(4);
  if (isocode_ == &_default_isocode_) {
    isocode_ = new ::std::string;
  }
  isocode_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Currency::mutable_isocode() {
  _set_bit(4);
  if (isocode_ == &_default_isocode_) {
    isocode_ = new ::std::string;
  }
  return isocode_;
}

// -------------------------------------------------------------------

// CurrencySeries

// repeated .symbology.Currency currency = 1;
inline int CurrencySeries::currency_size() const {
  return currency_.size();
}
inline void CurrencySeries::clear_currency() {
  currency_.Clear();
}
inline const ::symbology::Currency& CurrencySeries::currency(int index) const {
  return currency_.Get(index);
}
inline ::symbology::Currency* CurrencySeries::mutable_currency(int index) {
  return currency_.Mutable(index);
}
inline ::symbology::Currency* CurrencySeries::add_currency() {
  return currency_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::symbology::Currency >&
CurrencySeries::currency() const {
  return currency_;
}
inline ::google::protobuf::RepeatedPtrField< ::symbology::Currency >*
CurrencySeries::mutable_currency() {
  return &currency_;
}

// -------------------------------------------------------------------

// Market

// optional int32 id = 1;
inline bool Market::has_id() const {
  return _has_bit(0);
}
inline void Market::clear_id() {
  id_ = 0;
  _clear_bit(0);
}
inline ::google::protobuf::int32 Market::id() const {
  return id_;
}
inline void Market::set_id(::google::protobuf::int32 value) {
  _set_bit(0);
  id_ = value;
}

// optional .Revision revision = 2;
inline bool Market::has_revision() const {
  return _has_bit(1);
}
inline void Market::clear_revision() {
  if (revision_ != NULL) revision_->::Revision::Clear();
  _clear_bit(1);
}
inline const ::Revision& Market::revision() const {
  return revision_ != NULL ? *revision_ : *default_instance_->revision_;
}
inline ::Revision* Market::mutable_revision() {
  _set_bit(1);
  if (revision_ == NULL) revision_ = new ::Revision;
  return revision_;
}

// optional string name = 3;
inline bool Market::has_name() const {
  return _has_bit(2);
}
inline void Market::clear_name() {
  if (name_ != &_default_name_) {
    name_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& Market::name() const {
  return *name_;
}
inline void Market::set_name(const ::std::string& value) {
  _set_bit(2);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Market::set_name(const char* value) {
  _set_bit(2);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Market::set_name(const char* value, size_t size) {
  _set_bit(2);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Market::mutable_name() {
  _set_bit(2);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  return name_;
}

// optional string isoCode = 4;
inline bool Market::has_isocode() const {
  return _has_bit(3);
}
inline void Market::clear_isocode() {
  if (isocode_ != &_default_isocode_) {
    isocode_->clear();
  }
  _clear_bit(3);
}
inline const ::std::string& Market::isocode() const {
  return *isocode_;
}
inline void Market::set_isocode(const ::std::string& value) {
  _set_bit(3);
  if (isocode_ == &_default_isocode_) {
    isocode_ = new ::std::string;
  }
  isocode_->assign(value);
}
inline void Market::set_isocode(const char* value) {
  _set_bit(3);
  if (isocode_ == &_default_isocode_) {
    isocode_ = new ::std::string;
  }
  isocode_->assign(value);
}
inline void Market::set_isocode(const char* value, size_t size) {
  _set_bit(3);
  if (isocode_ == &_default_isocode_) {
    isocode_ = new ::std::string;
  }
  isocode_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Market::mutable_isocode() {
  _set_bit(3);
  if (isocode_ == &_default_isocode_) {
    isocode_ = new ::std::string;
  }
  return isocode_;
}

// optional .symbology.Country country = 5;
inline bool Market::has_country() const {
  return _has_bit(4);
}
inline void Market::clear_country() {
  if (country_ != NULL) country_->::symbology::Country::Clear();
  _clear_bit(4);
}
inline const ::symbology::Country& Market::country() const {
  return country_ != NULL ? *country_ : *default_instance_->country_;
}
inline ::symbology::Country* Market::mutable_country() {
  _set_bit(4);
  if (country_ == NULL) country_ = new ::symbology::Country;
  return country_;
}

// optional string city = 6;
inline bool Market::has_city() const {
  return _has_bit(5);
}
inline void Market::clear_city() {
  if (city_ != &_default_city_) {
    city_->clear();
  }
  _clear_bit(5);
}
inline const ::std::string& Market::city() const {
  return *city_;
}
inline void Market::set_city(const ::std::string& value) {
  _set_bit(5);
  if (city_ == &_default_city_) {
    city_ = new ::std::string;
  }
  city_->assign(value);
}
inline void Market::set_city(const char* value) {
  _set_bit(5);
  if (city_ == &_default_city_) {
    city_ = new ::std::string;
  }
  city_->assign(value);
}
inline void Market::set_city(const char* value, size_t size) {
  _set_bit(5);
  if (city_ == &_default_city_) {
    city_ = new ::std::string;
  }
  city_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Market::mutable_city() {
  _set_bit(5);
  if (city_ == &_default_city_) {
    city_ = new ::std::string;
  }
  return city_;
}

// optional string website = 7;
inline bool Market::has_website() const {
  return _has_bit(6);
}
inline void Market::clear_website() {
  if (website_ != &_default_website_) {
    website_->clear();
  }
  _clear_bit(6);
}
inline const ::std::string& Market::website() const {
  return *website_;
}
inline void Market::set_website(const ::std::string& value) {
  _set_bit(6);
  if (website_ == &_default_website_) {
    website_ = new ::std::string;
  }
  website_->assign(value);
}
inline void Market::set_website(const char* value) {
  _set_bit(6);
  if (website_ == &_default_website_) {
    website_ = new ::std::string;
  }
  website_->assign(value);
}
inline void Market::set_website(const char* value, size_t size) {
  _set_bit(6);
  if (website_ == &_default_website_) {
    website_ = new ::std::string;
  }
  website_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Market::mutable_website() {
  _set_bit(6);
  if (website_ == &_default_website_) {
    website_ = new ::std::string;
  }
  return website_;
}

// -------------------------------------------------------------------

// MarketSeries

// repeated .symbology.Market market = 1;
inline int MarketSeries::market_size() const {
  return market_.size();
}
inline void MarketSeries::clear_market() {
  market_.Clear();
}
inline const ::symbology::Market& MarketSeries::market(int index) const {
  return market_.Get(index);
}
inline ::symbology::Market* MarketSeries::mutable_market(int index) {
  return market_.Mutable(index);
}
inline ::symbology::Market* MarketSeries::add_market() {
  return market_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::symbology::Market >&
MarketSeries::market() const {
  return market_;
}
inline ::google::protobuf::RepeatedPtrField< ::symbology::Market >*
MarketSeries::mutable_market() {
  return &market_;
}

// -------------------------------------------------------------------

// Instrument

// optional int32 id = 1;
inline bool Instrument::has_id() const {
  return _has_bit(0);
}
inline void Instrument::clear_id() {
  id_ = 0;
  _clear_bit(0);
}
inline ::google::protobuf::int32 Instrument::id() const {
  return id_;
}
inline void Instrument::set_id(::google::protobuf::int32 value) {
  _set_bit(0);
  id_ = value;
}

// optional .Revision revision = 2;
inline bool Instrument::has_revision() const {
  return _has_bit(1);
}
inline void Instrument::clear_revision() {
  if (revision_ != NULL) revision_->::Revision::Clear();
  _clear_bit(1);
}
inline const ::Revision& Instrument::revision() const {
  return revision_ != NULL ? *revision_ : *default_instance_->revision_;
}
inline ::Revision* Instrument::mutable_revision() {
  _set_bit(1);
  if (revision_ == NULL) revision_ = new ::Revision;
  return revision_;
}

// optional int32 parentId = 3;
inline bool Instrument::has_parentid() const {
  return _has_bit(2);
}
inline void Instrument::clear_parentid() {
  parentid_ = 0;
  _clear_bit(2);
}
inline ::google::protobuf::int32 Instrument::parentid() const {
  return parentid_;
}
inline void Instrument::set_parentid(::google::protobuf::int32 value) {
  _set_bit(2);
  parentid_ = value;
}

// optional string name = 4;
inline bool Instrument::has_name() const {
  return _has_bit(3);
}
inline void Instrument::clear_name() {
  if (name_ != &_default_name_) {
    name_->clear();
  }
  _clear_bit(3);
}
inline const ::std::string& Instrument::name() const {
  return *name_;
}
inline void Instrument::set_name(const ::std::string& value) {
  _set_bit(3);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Instrument::set_name(const char* value) {
  _set_bit(3);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Instrument::set_name(const char* value, size_t size) {
  _set_bit(3);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Instrument::mutable_name() {
  _set_bit(3);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  return name_;
}

// -------------------------------------------------------------------

// InstrumentSeries

// repeated .symbology.Instrument instrument = 1;
inline int InstrumentSeries::instrument_size() const {
  return instrument_.size();
}
inline void InstrumentSeries::clear_instrument() {
  instrument_.Clear();
}
inline const ::symbology::Instrument& InstrumentSeries::instrument(int index) const {
  return instrument_.Get(index);
}
inline ::symbology::Instrument* InstrumentSeries::mutable_instrument(int index) {
  return instrument_.Mutable(index);
}
inline ::symbology::Instrument* InstrumentSeries::add_instrument() {
  return instrument_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::symbology::Instrument >&
InstrumentSeries::instrument() const {
  return instrument_;
}
inline ::google::protobuf::RepeatedPtrField< ::symbology::Instrument >*
InstrumentSeries::mutable_instrument() {
  return &instrument_;
}

// -------------------------------------------------------------------

// CounterParty

// optional int32 id = 1;
inline bool CounterParty::has_id() const {
  return _has_bit(0);
}
inline void CounterParty::clear_id() {
  id_ = 0;
  _clear_bit(0);
}
inline ::google::protobuf::int32 CounterParty::id() const {
  return id_;
}
inline void CounterParty::set_id(::google::protobuf::int32 value) {
  _set_bit(0);
  id_ = value;
}

// optional .Revision revision = 2;
inline bool CounterParty::has_revision() const {
  return _has_bit(1);
}
inline void CounterParty::clear_revision() {
  if (revision_ != NULL) revision_->::Revision::Clear();
  _clear_bit(1);
}
inline const ::Revision& CounterParty::revision() const {
  return revision_ != NULL ? *revision_ : *default_instance_->revision_;
}
inline ::Revision* CounterParty::mutable_revision() {
  _set_bit(1);
  if (revision_ == NULL) revision_ = new ::Revision;
  return revision_;
}

// optional string name = 3;
inline bool CounterParty::has_name() const {
  return _has_bit(2);
}
inline void CounterParty::clear_name() {
  if (name_ != &_default_name_) {
    name_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& CounterParty::name() const {
  return *name_;
}
inline void CounterParty::set_name(const ::std::string& value) {
  _set_bit(2);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void CounterParty::set_name(const char* value) {
  _set_bit(2);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void CounterParty::set_name(const char* value, size_t size) {
  _set_bit(2);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CounterParty::mutable_name() {
  _set_bit(2);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  return name_;
}

// optional string isoCode = 4;
inline bool CounterParty::has_isocode() const {
  return _has_bit(3);
}
inline void CounterParty::clear_isocode() {
  if (isocode_ != &_default_isocode_) {
    isocode_->clear();
  }
  _clear_bit(3);
}
inline const ::std::string& CounterParty::isocode() const {
  return *isocode_;
}
inline void CounterParty::set_isocode(const ::std::string& value) {
  _set_bit(3);
  if (isocode_ == &_default_isocode_) {
    isocode_ = new ::std::string;
  }
  isocode_->assign(value);
}
inline void CounterParty::set_isocode(const char* value) {
  _set_bit(3);
  if (isocode_ == &_default_isocode_) {
    isocode_ = new ::std::string;
  }
  isocode_->assign(value);
}
inline void CounterParty::set_isocode(const char* value, size_t size) {
  _set_bit(3);
  if (isocode_ == &_default_isocode_) {
    isocode_ = new ::std::string;
  }
  isocode_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CounterParty::mutable_isocode() {
  _set_bit(3);
  if (isocode_ == &_default_isocode_) {
    isocode_ = new ::std::string;
  }
  return isocode_;
}

// optional string website = 5;
inline bool CounterParty::has_website() const {
  return _has_bit(4);
}
inline void CounterParty::clear_website() {
  if (website_ != &_default_website_) {
    website_->clear();
  }
  _clear_bit(4);
}
inline const ::std::string& CounterParty::website() const {
  return *website_;
}
inline void CounterParty::set_website(const ::std::string& value) {
  _set_bit(4);
  if (website_ == &_default_website_) {
    website_ = new ::std::string;
  }
  website_->assign(value);
}
inline void CounterParty::set_website(const char* value) {
  _set_bit(4);
  if (website_ == &_default_website_) {
    website_ = new ::std::string;
  }
  website_->assign(value);
}
inline void CounterParty::set_website(const char* value, size_t size) {
  _set_bit(4);
  if (website_ == &_default_website_) {
    website_ = new ::std::string;
  }
  website_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CounterParty::mutable_website() {
  _set_bit(4);
  if (website_ == &_default_website_) {
    website_ = new ::std::string;
  }
  return website_;
}

// -------------------------------------------------------------------

// CounterPartySeries

// repeated .symbology.CounterParty counterParty = 1;
inline int CounterPartySeries::counterparty_size() const {
  return counterparty_.size();
}
inline void CounterPartySeries::clear_counterparty() {
  counterparty_.Clear();
}
inline const ::symbology::CounterParty& CounterPartySeries::counterparty(int index) const {
  return counterparty_.Get(index);
}
inline ::symbology::CounterParty* CounterPartySeries::mutable_counterparty(int index) {
  return counterparty_.Mutable(index);
}
inline ::symbology::CounterParty* CounterPartySeries::add_counterparty() {
  return counterparty_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::symbology::CounterParty >&
CounterPartySeries::counterparty() const {
  return counterparty_;
}
inline ::google::protobuf::RepeatedPtrField< ::symbology::CounterParty >*
CounterPartySeries::mutable_counterparty() {
  return &counterparty_;
}

// -------------------------------------------------------------------

// Company

// optional int32 id = 1;
inline bool Company::has_id() const {
  return _has_bit(0);
}
inline void Company::clear_id() {
  id_ = 0;
  _clear_bit(0);
}
inline ::google::protobuf::int32 Company::id() const {
  return id_;
}
inline void Company::set_id(::google::protobuf::int32 value) {
  _set_bit(0);
  id_ = value;
}

// optional .Revision revision = 2;
inline bool Company::has_revision() const {
  return _has_bit(1);
}
inline void Company::clear_revision() {
  if (revision_ != NULL) revision_->::Revision::Clear();
  _clear_bit(1);
}
inline const ::Revision& Company::revision() const {
  return revision_ != NULL ? *revision_ : *default_instance_->revision_;
}
inline ::Revision* Company::mutable_revision() {
  _set_bit(1);
  if (revision_ == NULL) revision_ = new ::Revision;
  return revision_;
}

// optional string name = 3;
inline bool Company::has_name() const {
  return _has_bit(2);
}
inline void Company::clear_name() {
  if (name_ != &_default_name_) {
    name_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& Company::name() const {
  return *name_;
}
inline void Company::set_name(const ::std::string& value) {
  _set_bit(2);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Company::set_name(const char* value) {
  _set_bit(2);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Company::set_name(const char* value, size_t size) {
  _set_bit(2);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Company::mutable_name() {
  _set_bit(2);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  return name_;
}

// -------------------------------------------------------------------

// CompanySeries

// repeated .symbology.Company company = 1;
inline int CompanySeries::company_size() const {
  return company_.size();
}
inline void CompanySeries::clear_company() {
  company_.Clear();
}
inline const ::symbology::Company& CompanySeries::company(int index) const {
  return company_.Get(index);
}
inline ::symbology::Company* CompanySeries::mutable_company(int index) {
  return company_.Mutable(index);
}
inline ::symbology::Company* CompanySeries::add_company() {
  return company_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::symbology::Company >&
CompanySeries::company() const {
  return company_;
}
inline ::google::protobuf::RepeatedPtrField< ::symbology::Company >*
CompanySeries::mutable_company() {
  return &company_;
}

// -------------------------------------------------------------------

// Security

// optional int32 id = 1;
inline bool Security::has_id() const {
  return _has_bit(0);
}
inline void Security::clear_id() {
  id_ = 0;
  _clear_bit(0);
}
inline ::google::protobuf::int32 Security::id() const {
  return id_;
}
inline void Security::set_id(::google::protobuf::int32 value) {
  _set_bit(0);
  id_ = value;
}

// optional .Revision revision = 2;
inline bool Security::has_revision() const {
  return _has_bit(1);
}
inline void Security::clear_revision() {
  if (revision_ != NULL) revision_->::Revision::Clear();
  _clear_bit(1);
}
inline const ::Revision& Security::revision() const {
  return revision_ != NULL ? *revision_ : *default_instance_->revision_;
}
inline ::Revision* Security::mutable_revision() {
  _set_bit(1);
  if (revision_ == NULL) revision_ = new ::Revision;
  return revision_;
}

// optional string name = 3;
inline bool Security::has_name() const {
  return _has_bit(2);
}
inline void Security::clear_name() {
  if (name_ != &_default_name_) {
    name_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& Security::name() const {
  return *name_;
}
inline void Security::set_name(const ::std::string& value) {
  _set_bit(2);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Security::set_name(const char* value) {
  _set_bit(2);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Security::set_name(const char* value, size_t size) {
  _set_bit(2);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Security::mutable_name() {
  _set_bit(2);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  return name_;
}

// optional .symbology.Instrument instrument = 4;
inline bool Security::has_instrument() const {
  return _has_bit(3);
}
inline void Security::clear_instrument() {
  if (instrument_ != NULL) instrument_->::symbology::Instrument::Clear();
  _clear_bit(3);
}
inline const ::symbology::Instrument& Security::instrument() const {
  return instrument_ != NULL ? *instrument_ : *default_instance_->instrument_;
}
inline ::symbology::Instrument* Security::mutable_instrument() {
  _set_bit(3);
  if (instrument_ == NULL) instrument_ = new ::symbology::Instrument;
  return instrument_;
}

// optional .symbology.Company company = 5;
inline bool Security::has_company() const {
  return _has_bit(4);
}
inline void Security::clear_company() {
  if (company_ != NULL) company_->::symbology::Company::Clear();
  _clear_bit(4);
}
inline const ::symbology::Company& Security::company() const {
  return company_ != NULL ? *company_ : *default_instance_->company_;
}
inline ::symbology::Company* Security::mutable_company() {
  _set_bit(4);
  if (company_ == NULL) company_ = new ::symbology::Company;
  return company_;
}

// optional .symbology.Currency currency = 6;
inline bool Security::has_currency() const {
  return _has_bit(5);
}
inline void Security::clear_currency() {
  if (currency_ != NULL) currency_->::symbology::Currency::Clear();
  _clear_bit(5);
}
inline const ::symbology::Currency& Security::currency() const {
  return currency_ != NULL ? *currency_ : *default_instance_->currency_;
}
inline ::symbology::Currency* Security::mutable_currency() {
  _set_bit(5);
  if (currency_ == NULL) currency_ = new ::symbology::Currency;
  return currency_;
}

// optional int32 strike = 7;
inline bool Security::has_strike() const {
  return _has_bit(6);
}
inline void Security::clear_strike() {
  strike_ = 0;
  _clear_bit(6);
}
inline ::google::protobuf::int32 Security::strike() const {
  return strike_;
}
inline void Security::set_strike(::google::protobuf::int32 value) {
  _set_bit(6);
  strike_ = value;
}

// optional int32 expirationDate = 8;
inline bool Security::has_expirationdate() const {
  return _has_bit(7);
}
inline void Security::clear_expirationdate() {
  expirationdate_ = 0;
  _clear_bit(7);
}
inline ::google::protobuf::int32 Security::expirationdate() const {
  return expirationdate_;
}
inline void Security::set_expirationdate(::google::protobuf::int32 value) {
  _set_bit(7);
  expirationdate_ = value;
}

// -------------------------------------------------------------------

// SecuritySeries

// repeated .symbology.Security security = 1;
inline int SecuritySeries::security_size() const {
  return security_.size();
}
inline void SecuritySeries::clear_security() {
  security_.Clear();
}
inline const ::symbology::Security& SecuritySeries::security(int index) const {
  return security_.Get(index);
}
inline ::symbology::Security* SecuritySeries::mutable_security(int index) {
  return security_.Mutable(index);
}
inline ::symbology::Security* SecuritySeries::add_security() {
  return security_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::symbology::Security >&
SecuritySeries::security() const {
  return security_;
}
inline ::google::protobuf::RepeatedPtrField< ::symbology::Security >*
SecuritySeries::mutable_security() {
  return &security_;
}

// -------------------------------------------------------------------

// Symbol

// optional int32 id = 1;
inline bool Symbol::has_id() const {
  return _has_bit(0);
}
inline void Symbol::clear_id() {
  id_ = 0;
  _clear_bit(0);
}
inline ::google::protobuf::int32 Symbol::id() const {
  return id_;
}
inline void Symbol::set_id(::google::protobuf::int32 value) {
  _set_bit(0);
  id_ = value;
}

// optional .Revision revision = 2;
inline bool Symbol::has_revision() const {
  return _has_bit(1);
}
inline void Symbol::clear_revision() {
  if (revision_ != NULL) revision_->::Revision::Clear();
  _clear_bit(1);
}
inline const ::Revision& Symbol::revision() const {
  return revision_ != NULL ? *revision_ : *default_instance_->revision_;
}
inline ::Revision* Symbol::mutable_revision() {
  _set_bit(1);
  if (revision_ == NULL) revision_ = new ::Revision;
  return revision_;
}

// optional .symbology.Currency currency = 3;
inline bool Symbol::has_currency() const {
  return _has_bit(2);
}
inline void Symbol::clear_currency() {
  if (currency_ != NULL) currency_->::symbology::Currency::Clear();
  _clear_bit(2);
}
inline const ::symbology::Currency& Symbol::currency() const {
  return currency_ != NULL ? *currency_ : *default_instance_->currency_;
}
inline ::symbology::Currency* Symbol::mutable_currency() {
  _set_bit(2);
  if (currency_ == NULL) currency_ = new ::symbology::Currency;
  return currency_;
}

// optional .symbology.Security security = 4;
inline bool Symbol::has_security() const {
  return _has_bit(3);
}
inline void Symbol::clear_security() {
  if (security_ != NULL) security_->::symbology::Security::Clear();
  _clear_bit(3);
}
inline const ::symbology::Security& Symbol::security() const {
  return security_ != NULL ? *security_ : *default_instance_->security_;
}
inline ::symbology::Security* Symbol::mutable_security() {
  _set_bit(3);
  if (security_ == NULL) security_ = new ::symbology::Security;
  return security_;
}

// optional .symbology.CounterParty counterParty = 5;
inline bool Symbol::has_counterparty() const {
  return _has_bit(4);
}
inline void Symbol::clear_counterparty() {
  if (counterparty_ != NULL) counterparty_->::symbology::CounterParty::Clear();
  _clear_bit(4);
}
inline const ::symbology::CounterParty& Symbol::counterparty() const {
  return counterparty_ != NULL ? *counterparty_ : *default_instance_->counterparty_;
}
inline ::symbology::CounterParty* Symbol::mutable_counterparty() {
  _set_bit(4);
  if (counterparty_ == NULL) counterparty_ = new ::symbology::CounterParty;
  return counterparty_;
}

// optional string name = 6;
inline bool Symbol::has_name() const {
  return _has_bit(5);
}
inline void Symbol::clear_name() {
  if (name_ != &_default_name_) {
    name_->clear();
  }
  _clear_bit(5);
}
inline const ::std::string& Symbol::name() const {
  return *name_;
}
inline void Symbol::set_name(const ::std::string& value) {
  _set_bit(5);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Symbol::set_name(const char* value) {
  _set_bit(5);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Symbol::set_name(const char* value, size_t size) {
  _set_bit(5);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Symbol::mutable_name() {
  _set_bit(5);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  return name_;
}

// -------------------------------------------------------------------

// SymbolSeries

// repeated .symbology.Symbol symbol = 1;
inline int SymbolSeries::symbol_size() const {
  return symbol_.size();
}
inline void SymbolSeries::clear_symbol() {
  symbol_.Clear();
}
inline const ::symbology::Symbol& SymbolSeries::symbol(int index) const {
  return symbol_.Get(index);
}
inline ::symbology::Symbol* SymbolSeries::mutable_symbol(int index) {
  return symbol_.Mutable(index);
}
inline ::symbology::Symbol* SymbolSeries::add_symbol() {
  return symbol_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::symbology::Symbol >&
SymbolSeries::symbol() const {
  return symbol_;
}
inline ::google::protobuf::RepeatedPtrField< ::symbology::Symbol >*
SymbolSeries::mutable_symbol() {
  return &symbol_;
}

// -------------------------------------------------------------------

// ExchangeRate

// optional int32 id = 1;
inline bool ExchangeRate::has_id() const {
  return _has_bit(0);
}
inline void ExchangeRate::clear_id() {
  id_ = 0;
  _clear_bit(0);
}
inline ::google::protobuf::int32 ExchangeRate::id() const {
  return id_;
}
inline void ExchangeRate::set_id(::google::protobuf::int32 value) {
  _set_bit(0);
  id_ = value;
}

// optional .Revision revision = 2;
inline bool ExchangeRate::has_revision() const {
  return _has_bit(1);
}
inline void ExchangeRate::clear_revision() {
  if (revision_ != NULL) revision_->::Revision::Clear();
  _clear_bit(1);
}
inline const ::Revision& ExchangeRate::revision() const {
  return revision_ != NULL ? *revision_ : *default_instance_->revision_;
}
inline ::Revision* ExchangeRate::mutable_revision() {
  _set_bit(1);
  if (revision_ == NULL) revision_ = new ::Revision;
  return revision_;
}

// optional .symbology.Currency toCurrency = 3;
inline bool ExchangeRate::has_tocurrency() const {
  return _has_bit(2);
}
inline void ExchangeRate::clear_tocurrency() {
  if (tocurrency_ != NULL) tocurrency_->::symbology::Currency::Clear();
  _clear_bit(2);
}
inline const ::symbology::Currency& ExchangeRate::tocurrency() const {
  return tocurrency_ != NULL ? *tocurrency_ : *default_instance_->tocurrency_;
}
inline ::symbology::Currency* ExchangeRate::mutable_tocurrency() {
  _set_bit(2);
  if (tocurrency_ == NULL) tocurrency_ = new ::symbology::Currency;
  return tocurrency_;
}

// optional .symbology.Currency fromCurrency = 4;
inline bool ExchangeRate::has_fromcurrency() const {
  return _has_bit(3);
}
inline void ExchangeRate::clear_fromcurrency() {
  if (fromcurrency_ != NULL) fromcurrency_->::symbology::Currency::Clear();
  _clear_bit(3);
}
inline const ::symbology::Currency& ExchangeRate::fromcurrency() const {
  return fromcurrency_ != NULL ? *fromcurrency_ : *default_instance_->fromcurrency_;
}
inline ::symbology::Currency* ExchangeRate::mutable_fromcurrency() {
  _set_bit(3);
  if (fromcurrency_ == NULL) fromcurrency_ = new ::symbology::Currency;
  return fromcurrency_;
}

// optional .symbology.CounterParty counterParty = 5;
inline bool ExchangeRate::has_counterparty() const {
  return _has_bit(4);
}
inline void ExchangeRate::clear_counterparty() {
  if (counterparty_ != NULL) counterparty_->::symbology::CounterParty::Clear();
  _clear_bit(4);
}
inline const ::symbology::CounterParty& ExchangeRate::counterparty() const {
  return counterparty_ != NULL ? *counterparty_ : *default_instance_->counterparty_;
}
inline ::symbology::CounterParty* ExchangeRate::mutable_counterparty() {
  _set_bit(4);
  if (counterparty_ == NULL) counterparty_ = new ::symbology::CounterParty;
  return counterparty_;
}

// optional int64 time = 6;
inline bool ExchangeRate::has_time() const {
  return _has_bit(5);
}
inline void ExchangeRate::clear_time() {
  time_ = GOOGLE_LONGLONG(0);
  _clear_bit(5);
}
inline ::google::protobuf::int64 ExchangeRate::time() const {
  return time_;
}
inline void ExchangeRate::set_time(::google::protobuf::int64 value) {
  _set_bit(5);
  time_ = value;
}

// optional int32 rate = 7;
inline bool ExchangeRate::has_rate() const {
  return _has_bit(6);
}
inline void ExchangeRate::clear_rate() {
  rate_ = 0;
  _clear_bit(6);
}
inline ::google::protobuf::int32 ExchangeRate::rate() const {
  return rate_;
}
inline void ExchangeRate::set_rate(::google::protobuf::int32 value) {
  _set_bit(6);
  rate_ = value;
}

// -------------------------------------------------------------------

// ExchangeRateSeries

// repeated .symbology.ExchangeRate exchangeRate = 1;
inline int ExchangeRateSeries::exchangerate_size() const {
  return exchangerate_.size();
}
inline void ExchangeRateSeries::clear_exchangerate() {
  exchangerate_.Clear();
}
inline const ::symbology::ExchangeRate& ExchangeRateSeries::exchangerate(int index) const {
  return exchangerate_.Get(index);
}
inline ::symbology::ExchangeRate* ExchangeRateSeries::mutable_exchangerate(int index) {
  return exchangerate_.Mutable(index);
}
inline ::symbology::ExchangeRate* ExchangeRateSeries::add_exchangerate() {
  return exchangerate_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::symbology::ExchangeRate >&
ExchangeRateSeries::exchangerate() const {
  return exchangerate_;
}
inline ::google::protobuf::RepeatedPtrField< ::symbology::ExchangeRate >*
ExchangeRateSeries::mutable_exchangerate() {
  return &exchangerate_;
}

// -------------------------------------------------------------------

// Price

// optional int32 id = 1;
inline bool Price::has_id() const {
  return _has_bit(0);
}
inline void Price::clear_id() {
  id_ = 0;
  _clear_bit(0);
}
inline ::google::protobuf::int32 Price::id() const {
  return id_;
}
inline void Price::set_id(::google::protobuf::int32 value) {
  _set_bit(0);
  id_ = value;
}

// optional .Revision revision = 2;
inline bool Price::has_revision() const {
  return _has_bit(1);
}
inline void Price::clear_revision() {
  if (revision_ != NULL) revision_->::Revision::Clear();
  _clear_bit(1);
}
inline const ::Revision& Price::revision() const {
  return revision_ != NULL ? *revision_ : *default_instance_->revision_;
}
inline ::Revision* Price::mutable_revision() {
  _set_bit(1);
  if (revision_ == NULL) revision_ = new ::Revision;
  return revision_;
}

// optional .symbology.Security security = 3;
inline bool Price::has_security() const {
  return _has_bit(2);
}
inline void Price::clear_security() {
  if (security_ != NULL) security_->::symbology::Security::Clear();
  _clear_bit(2);
}
inline const ::symbology::Security& Price::security() const {
  return security_ != NULL ? *security_ : *default_instance_->security_;
}
inline ::symbology::Security* Price::mutable_security() {
  _set_bit(2);
  if (security_ == NULL) security_ = new ::symbology::Security;
  return security_;
}

// optional .symbology.CounterParty counterParty = 4;
inline bool Price::has_counterparty() const {
  return _has_bit(3);
}
inline void Price::clear_counterparty() {
  if (counterparty_ != NULL) counterparty_->::symbology::CounterParty::Clear();
  _clear_bit(3);
}
inline const ::symbology::CounterParty& Price::counterparty() const {
  return counterparty_ != NULL ? *counterparty_ : *default_instance_->counterparty_;
}
inline ::symbology::CounterParty* Price::mutable_counterparty() {
  _set_bit(3);
  if (counterparty_ == NULL) counterparty_ = new ::symbology::CounterParty;
  return counterparty_;
}

// optional .symbology.Currency currency = 5;
inline bool Price::has_currency() const {
  return _has_bit(4);
}
inline void Price::clear_currency() {
  if (currency_ != NULL) currency_->::symbology::Currency::Clear();
  _clear_bit(4);
}
inline const ::symbology::Currency& Price::currency() const {
  return currency_ != NULL ? *currency_ : *default_instance_->currency_;
}
inline ::symbology::Currency* Price::mutable_currency() {
  _set_bit(4);
  if (currency_ == NULL) currency_ = new ::symbology::Currency;
  return currency_;
}

// optional int32 date = 6;
inline bool Price::has_date() const {
  return _has_bit(5);
}
inline void Price::clear_date() {
  date_ = 0;
  _clear_bit(5);
}
inline ::google::protobuf::int32 Price::date() const {
  return date_;
}
inline void Price::set_date(::google::protobuf::int32 value) {
  _set_bit(5);
  date_ = value;
}

// optional int32 bid = 7;
inline bool Price::has_bid() const {
  return _has_bit(6);
}
inline void Price::clear_bid() {
  bid_ = 0;
  _clear_bit(6);
}
inline ::google::protobuf::int32 Price::bid() const {
  return bid_;
}
inline void Price::set_bid(::google::protobuf::int32 value) {
  _set_bit(6);
  bid_ = value;
}

// optional int32 ask = 8;
inline bool Price::has_ask() const {
  return _has_bit(7);
}
inline void Price::clear_ask() {
  ask_ = 0;
  _clear_bit(7);
}
inline ::google::protobuf::int32 Price::ask() const {
  return ask_;
}
inline void Price::set_ask(::google::protobuf::int32 value) {
  _set_bit(7);
  ask_ = value;
}

// optional int32 open = 9;
inline bool Price::has_open() const {
  return _has_bit(8);
}
inline void Price::clear_open() {
  open_ = 0;
  _clear_bit(8);
}
inline ::google::protobuf::int32 Price::open() const {
  return open_;
}
inline void Price::set_open(::google::protobuf::int32 value) {
  _set_bit(8);
  open_ = value;
}

// optional int32 close = 10;
inline bool Price::has_close() const {
  return _has_bit(9);
}
inline void Price::clear_close() {
  close_ = 0;
  _clear_bit(9);
}
inline ::google::protobuf::int32 Price::close() const {
  return close_;
}
inline void Price::set_close(::google::protobuf::int32 value) {
  _set_bit(9);
  close_ = value;
}

// optional int32 high = 11;
inline bool Price::has_high() const {
  return _has_bit(10);
}
inline void Price::clear_high() {
  high_ = 0;
  _clear_bit(10);
}
inline ::google::protobuf::int32 Price::high() const {
  return high_;
}
inline void Price::set_high(::google::protobuf::int32 value) {
  _set_bit(10);
  high_ = value;
}

// optional int32 low = 12;
inline bool Price::has_low() const {
  return _has_bit(11);
}
inline void Price::clear_low() {
  low_ = 0;
  _clear_bit(11);
}
inline ::google::protobuf::int32 Price::low() const {
  return low_;
}
inline void Price::set_low(::google::protobuf::int32 value) {
  _set_bit(11);
  low_ = value;
}

// optional int32 volume = 13;
inline bool Price::has_volume() const {
  return _has_bit(12);
}
inline void Price::clear_volume() {
  volume_ = 0;
  _clear_bit(12);
}
inline ::google::protobuf::int32 Price::volume() const {
  return volume_;
}
inline void Price::set_volume(::google::protobuf::int32 value) {
  _set_bit(12);
  volume_ = value;
}

// optional int32 return = 14;
inline bool Price::has_return_() const {
  return _has_bit(13);
}
inline void Price::clear_return_() {
  return__ = 0;
  _clear_bit(13);
}
inline ::google::protobuf::int32 Price::return_() const {
  return return__;
}
inline void Price::set_return_(::google::protobuf::int32 value) {
  _set_bit(13);
  return__ = value;
}

// -------------------------------------------------------------------

// PriceSeries

// repeated .symbology.Price price = 1;
inline int PriceSeries::price_size() const {
  return price_.size();
}
inline void PriceSeries::clear_price() {
  price_.Clear();
}
inline const ::symbology::Price& PriceSeries::price(int index) const {
  return price_.Get(index);
}
inline ::symbology::Price* PriceSeries::mutable_price(int index) {
  return price_.Mutable(index);
}
inline ::symbology::Price* PriceSeries::add_price() {
  return price_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::symbology::Price >&
PriceSeries::price() const {
  return price_;
}
inline ::google::protobuf::RepeatedPtrField< ::symbology::Price >*
PriceSeries::mutable_price() {
  return &price_;
}

// -------------------------------------------------------------------

// Event

// optional int32 id = 1;
inline bool Event::has_id() const {
  return _has_bit(0);
}
inline void Event::clear_id() {
  id_ = 0;
  _clear_bit(0);
}
inline ::google::protobuf::int32 Event::id() const {
  return id_;
}
inline void Event::set_id(::google::protobuf::int32 value) {
  _set_bit(0);
  id_ = value;
}

// optional .Revision revision = 2;
inline bool Event::has_revision() const {
  return _has_bit(1);
}
inline void Event::clear_revision() {
  if (revision_ != NULL) revision_->::Revision::Clear();
  _clear_bit(1);
}
inline const ::Revision& Event::revision() const {
  return revision_ != NULL ? *revision_ : *default_instance_->revision_;
}
inline ::Revision* Event::mutable_revision() {
  _set_bit(1);
  if (revision_ == NULL) revision_ = new ::Revision;
  return revision_;
}

// -------------------------------------------------------------------

// EventSeries

// repeated .symbology.Event event = 1;
inline int EventSeries::event_size() const {
  return event_.size();
}
inline void EventSeries::clear_event() {
  event_.Clear();
}
inline const ::symbology::Event& EventSeries::event(int index) const {
  return event_.Get(index);
}
inline ::symbology::Event* EventSeries::mutable_event(int index) {
  return event_.Mutable(index);
}
inline ::symbology::Event* EventSeries::add_event() {
  return event_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::symbology::Event >&
EventSeries::event() const {
  return event_;
}
inline ::google::protobuf::RepeatedPtrField< ::symbology::Event >*
EventSeries::mutable_event() {
  return &event_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace symbology

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::symbology::CounterParty_type>() {
  return ::symbology::CounterParty_type_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::symbology::Symbol_type>() {
  return ::symbology::Symbol_type_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_Symbology_2eproto__INCLUDED
